	Keep	Led.Msg	mcopy	LedMsg.macsMaxDHitable gequ	2MaxDItemNum gequ	5	copy	T2.common.asmSpeed	gequ	2	;1/20 second**Globals	data** The Blanker's global data segment**rLedMsgText str	'LedMsg: Text'rLEDMsgFont	str	'LedMsg: Font'TheText	dosout	500	;504 byte buffer for text...MsgLen	equ	TheText+2	;actual length of textErrText	dosin	'Twilight II is Awesome!   This LED Message module was programmed by Nathan Mates, with special thanks to Jim Maricondo (code), the FTA (more code), Beagle Bros (font), and is dedicated to Ah-Ram Kim...'* Other stuff :)	end**DoBlankT2	Start** Main blanker code**	using	CommonData	using	Globals	jsr	DoBlankT2_2	;do the setup and all...MovePtr	equ	4	;placed here by DoBlankT2_2* BlahMainLoop	lda	[MovePtr]	bne	Done* Blahdone	rts	end**DoMakeT2	start** Handles the making of all the stuff in the setup window**	using	Globals	using	CommonData	jsr	DoMakeT2_2	;call back for common stuff...	ldx	#0	;high word of resource ID	ldy	#1	;low word of resource ID	jsr	LoadCtrlsByID* Make sure we're dealing with the T2pref file.	WordResult	_GetCurResourceFile	PushWord	RezFileID	_SetCurResourceFile	jsr	load_setupnoShapes1	anopMoveOn	_SetCurResourceFile	PushWord	#%011	;ptr to gs/os output string	PushLong	#TheText	PushWord	#0	;upper word of length	PushWord	MsgLen	;length of block	PushWord	#0	;ptr to TEFormat...	PushLong	#0	;nil ptr	LongResult	PushLong	WindPtr	PushLong	#1	;TE Control ID	_GetCtlHandleFromID	_TESetText	lda	TheFont	;value to set it to	ldy	#2	;Low Word, control #	jsr	SetCtlToVal	rts		;or just jmp there...	end**DoLoadSetupT2 start** Handles the loading of all the stuff from the prefs file and all**	using	Globals	using	CommonData	jsr	load_setup	rtsTextNotThere anop		;text not on disk, so make our own...	ldx	ErrText	;length word	inx	inx		;length of whole thingCopyErr2	lda	ErrText,x	sta	TheText+2,x	dex		;copy all words in string	dex	bpl	CopyErr2	lda	ErrText	;accound for possibility of odd-length string	sta	TheText+2	rtsTextIsThere anop	ldy	#504GetText	lda	[3],y	;pointer on stack...	sta	TheText,y	dey	dey	bpl	GetText	mov	#500,TheText	;buffer size	rtsload_setup	entry	PushWord #TextIsThere ;address of function if font is on disk 	PushWord #TextNotThere ;address of function if text is not on disk	lda	#rC1OutputString ;resource type	ldx	#rLedMsgText	ldy	#1	;function calls	jsr	LoadAPref	PushWord #300	;default value	PushWord #TheFont	;pointer to word-variable to store it in	lda	#rT2ModuleWord ;type	ldx	#rLEDMsgFont	ldy	#0	;loading only a word	jsr	LoadAPref	LongResult	PushLong	WindPtr	PushLong	#1	;TE Control ID	_GetCtlHandleFromID	jsr	MakePdp	ldy	#$10	lda	[3],y	and	#%1111111110111111	sta	[3],y	;mark saved	killLdp	rts	end**DoSaveT2	start** Handles the saving of the module's prefs and all**	using	Globals	using	CommonData** First, grab data from controls in window.*	LongResult	PushWord	#%011	;ptr to gs/os output string	PushLong	#TheText	PushLong	#500	;length of buffer size	PushWord	#0	;ptr to TEFormat...	PushLong	#0	;nil ptr	LongResult	PushLong	WindPtr	PushLong	#1	;TE Control ID	_GetCtlHandleFromID	ldy	#$10	lda	[3],y	and	#%1111111110111111	sta	[3],y	;mark saved	lda	3,s	;duplicate handle	pha	lda	3,s	pha	_TECompactRecord	_TEGetText	pla	pla		;throw away result	ldy	#2	;font popup	jsr	GetACtlVal	sta	TheFont	;leave in memory for blanker's use**  Got data into the program, now store it to disk*	WordResult	_GetCurResourceFile	PushWord	RezFileID	_SetCurResourceFile	PushWord #504	;length of block in bytes	PushWord #SaveText	;function ptr	lda	#rC1OutputString	  ;resource type	ldx	#rLedMsgText ;ptr to name string	jsr	SaveAPref	PushWord #2	;length of block in bytes	PushWord TheFont	;Value to store	lda	#rT2ModuleWord	ldx	#rLedMsgFont ;ptr to name string	jsr	SaveAPref	PushWord	RezFileID	_UpdateResourceFile	_SetCurResourceFile	rtsSaveText	mov	#500,TheText	;buffer size	ldy	#504SaveTheText	lda	TheText,y	sta	[3],y	dey	dey	bpl	SaveTheText	rts	end**DoHitT2	start** Handle Item hits**	using	CommonDataT2Data2	equ	5T2Result	equ	15	stz	T2Result+2	stz	T2Result	;assume nothing hit	lda	T2data2+2	;ctlID hi word must be zero	bne	nothingHit	lda	T2data2	;get ctlID	dec	a	beq	enable	;branch if was 1 (TE Control)	dec	a	beq	HitItnothingHit	rtsenable	anop	LongResult	PushLong	WindPtr	PushLong	#1	;TE Control ID	_GetCtlHandleFromID	jsr	MakePdp	ldy	#$10	lda	[3],y	pld	plx	plx		;keep a-reg intact	and	#$40	;dirty bit: has it changed?	beq	NothingHitHitIt	lda	#TRUE	sta	T2Result	rts	end**DoKillT2	start** "Handles" actions not supported by this module**DoUnloadSetupT2 entry	rts		;act very noncholant about it	end